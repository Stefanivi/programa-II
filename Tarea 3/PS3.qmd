---
title: "PS3"
format:
  html:
    #toc: true
    html-math-method: katex
edito: visual
---

Programación II\
Programa de Estudios Superiores\
Banco de Guatemala\
2025

**Integrantes:**\

-   Paulo Augusto Garrido Grijalva
-   Stefani María Villeda Guerra
-   Luis Daniel Monroy Rojas
-   David Javier García Sutuj

***Preparación de workspace***
````{r, warning=FALSE}
rm(list=ls())
graphics.off()
setwd("C:\\Users\\danie\\Documents\\CursoProgra_2R\\programa-II\\Tarea 3")
````

# Estimación de un AR(1), Parte I

Considere el proceso: $$
y_t = \mu + \rho y_{t-1} + \varepsilon_t
$$

Donde $$
\varepsilon_t \sim \mathcal{N}(0,\sigma^2)\quad \text{y}\quad y_1 \sim \mathcal{N}\!\left(\frac{\mu}{1-\rho},\, \frac{\sigma^2}{1-\rho^2}\right)
$$

1.  Cree una función que evalúe la log-verosimilitud del proceso en el punto $\theta = [\mu, \rho, \sigma^2]$, dadas las observaciones $y_t$ simuladas.

Función de log-verosimilitud (para una muestra tamaño T)

```{r}
log_verosimilitud <- function(theta, y) {
    T <- length(y)
    mu <- theta[1]
    rho <- theta[2]
    sigma2 <- theta[3]

    resultado <- (-1/2 * log(2 * pi) - 1/2 * log(sigma2/(1-rho^2))
                    -(y[1] - (mu/(1-rho)))^2 / ((2*sigma2)/(1-rho^2))
                    -((T-1)/2) * log(2 * pi)
                    -((T-1)/2) * log(sigma2)
                    -sum((y[2:T] - mu - rho * y[1:(T-1)])^2) / (2*sigma2)
                 )
    return(-resultado)
}
```

2.  Genere el vector $\varepsilon_t$ y el valor inicial $y_1$, y simule $T = 100$ observaciones del proceso $y_t$ con los parámetros $\mu = 1$, $\rho = 0.4$ y $\sigma^2 = 0.5$

Valor iniciar $y_1$

```{r}
set.seed(1)
mu <- 1
rho <- 0.4
sigma2 <- 0.5
y_1<-rnorm(1, mu/(1-rho), sd=sqrt(sigma2/(1-rho^2)))
y_1

```

Vector de epsilon:

```{r}

simular_y <- function() {
    T <- 100
    mu <- 1
    rho <- 0.4
    sigma2 <- 0.5
    
    # Ahora calculamos el vector de epsilon hasta T
    # usando distribución normal
    epsilon <- rnorm(T, mean=0, sd=sqrt(sigma2))
    
    # Calcular el vector yt
    y <- c()
    y[1] <- rnorm(1, mu/(1-rho), sd=sqrt(sigma2/(1-rho^2)))
    #print(y[1])
    for (i in 2:T) {
        y[i] <- mu + rho * y[i-1]+epsilon[i]
    }
    return(y)
}

set.seed(1)
vector_epsilon<-simular_y()
vector_epsilon
```
3.  Use una función de optimización numérica para encontrar el estimador de máxima verosimilitud $\hat{\theta} = [\hat{\mu}, \hat{\rho}, \hat{\sigma}^2]$, definido como el vector de parámetros que maximiza la función de log-verosimilitud dados los datos simulados en el punto anterior. (Use como valores iniciales el vector $\theta = [0.5, 0.5, 0.5]'$).

```{r, echo=FALSE, warning=FALSE}
#Función de optimización de máxima verosimilitud 
simular_optim <- function(y) {
    theta_inicial <- c(0.5, 0.5, 0.5)

    resultado <- optim(
                    par     = theta_inicial,
                    fn      = log_verosimilitud,
                    y       = y,
                    method  = "BFGS",
                    hessian = TRUE
                )

    return(resultado)
}
```

```{r,warning=FALSE}
theta_simulado <- simular_optim(vector_epsilon)
theta_simulado$par
```

4.  Cree un ciclo que repita 1000 veces los pasos en los puntos (2) a (3) y guarde los valores de $\theta = [\mu, \rho, \sigma^2]$ obtenidos en cada iteración. Grafique el histograma de frecuencias de la distribución del estimador de cada uno de estos parámetros.

```{r, warning=FALSE}
#Simulación Monte Carlo
simular_n_veces <- function() {
    y <- c()
    df_resultados <- data.frame(mu = numeric(), rho=numeric(), sigma2=numeric())
    for (i in 1:100) {
        y <- simular_y()
        res <- simular_optim(y)
        df_resultados <- rbind(df_resultados,
                                data.frame(mu = res$par[1],
                                            rho = res$par[2],
                                            sigma2 = res$par[3]
                                        )
                                )
    }
    return(df_resultados)
}
df_res_simulados <- simular_n_veces()
head(df_res_simulados, 5)
```

```{r, warning=FALSE}
#Gráficas de histograma
par(mfrow = c(1,3))
for (col in names(df_res_simulados)) {
    hist(df_res_simulados[[col]], 
       main = paste("Histograma de", col), 
       xlab = col,
       col = "skyblue", 
       border = "white")
}
par(mfrow = c(1,1))
```

# Estimación de un AR(1), Parte II

Bajo ciertas condiciones de regularidad, el estimador de máxima verosimilitud converge en distribución:

$$
\sqrt{T}\,(\hat{\theta} - \theta_0) \;\;\xrightarrow{d}\;\; \mathcal{N}(0, J_1^{-1})
$$
Donde 0 is valor poblacional de y J1 es la matriz de segundas derivadas de la función de verosimilitud 

$$
J_1 = E[-H(\theta)] \;=\; -E\!\left[ \frac{\partial^2 \log \mathcal{L}(\theta)}{\partial \theta \,\partial \theta^T} \right]
$$

Bajo condiciones de regularidad adicionales, esta matriz se puede estimar de forma consistente usando su contraparte muestral:
$$
\hat{J}_1 \;=\; -\frac{1}{T} 
\left. \frac{\partial^2 \log \mathcal{L}(\theta)}{\partial \theta \,\partial \theta^T} \right|_{\theta=\hat{\theta}}
$$

Se tiene entonces que

$$
\hat{\theta} \;\approx\; \mathcal{N}\!\left(\theta_0,\; \frac{1}{T}\,\hat{J}_1^{-1}\right)
$$
1. Escriba una función que calcule los errores estándar del estimador de 
máxima verosimilitud $\hat{\theta}$.

```{r}
#Función que calcule los errores estándar del estimador de máxima verosimilitud

errores_estandares <- function(data) {

    # Obtener el Hessiano en el punto optimo
    res <- simular_optim(data)
    hessian_log <- res$hessian

    #Calculo de J1 hat
    T_len<- length(data)
    J1_hat <- (1/T_len) * hessian_log
    J1_hat

    # Para obtener J1_hat invertido usamos la función solve
    cov_hat <- solve(J1_hat) / T_len
    cov_hat

    # EE: errores estandar
    ee <- sqrt(diag(cov_hat))
    return(ee)
}
```

2. Utilice el código anterior para encontrar el estimador de máxima 
verosimilitud de un $AR(1)$ y sus errores estándar asociados para la serie 
de inflación mensual en la hoja de Excel adjunta a este taller.

Estimador máximo $\hat{\theta} = [\hat{\mu}, \hat{\rho}, \hat{\sigma}^2]=$

```{r, warning=FALSE}
data_inflacion <- read.csv(file="inflacion.csv", header = TRUE, fileEncoding = "latin1")
names(data_inflacion) = c("mes", "inflacion")

set.seed(1)
optimo_datos <- simular_optim(data_inflacion$inflacion)
optimo_datos$par

```
```{r,warning=FALSE}
ee_inflacion <- errores_estandares(data_inflacion$inflacion)
ee_inflacion
```

